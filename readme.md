# CLI для прогноза погоды

## Описание

Этот CLI-инструмент позволяет получать прогноз погоды для указанного города или текущего местоположения пользователя.

## Установка

1. Убедитесь, что у вас установлен Go (версия 1.16 или выше).
2. Склонируйте репозиторий:
   ```sh
   git clone https://github.com/Mazurchik-Marta/go-demo-5
   cd go-demo-5
   ```
3. Соберите исполняемый файл:
   ```sh
   go build -o go-demo-5
   ```

## Использование

### Получение прогноза погоды по названию города

```sh
./go-demo-5 -city "Moscow" -format 2
```

### Получение прогноза погоды по текущему местоположению

```sh
./go-demo-5 -format 1
```

## Аргументы

- `-city` (строка) – Название города, для которого необходимо получить прогноз погоды.
- `-format` (целое число) – Формат вывода прогноза погоды (1, 2, 3). Значения соответствуют параметрам API wttr.in:
  - `1` – краткий прогноз
  - `2` – подробный прогноз
  - `3` – прогноз с иконками

## Принцип работы

1. Если указан город, выполняется проверка его существования с помощью внешнего API.
2. Если город не указан, определяется местоположение пользователя с помощью `ipapi.co`.
3. Полученные геоданные передаются в API `wttr.in` для получения прогноза погоды.
4. Прогноз погоды выводится в указанном формате.
5. Также проверка локации осуществляется через сервис `countriesnow.space/api/v0.1`

## Принцип работы main

Функция `main` в данном коде выполняет следующие шаги:
### 1. Определение флагов командной строки  
```go
city := flag.String("city", "", "Город пользователя")
format := flag.Int("format", 1, "Формат вывода погоды")
```
Здесь используются функции пакета `flag`, которые позволяют получать аргументы командной строки:  
- `flag.String("city", "", "Город пользователя")`  
  - Определяет флаг `-city` (например, `-city Moscow`).
  - Значение по умолчанию — пустая строка `""`.
  - `city` — это указатель на строку (`*string`).
- `flag.Int("format", 1, "Формат вывода погоды")`  
  - Определяет флаг `-format` (например, `-fotmat 2`).
  - Значение по умолчанию — `1`.
  - `format` — это указатель на `int` (`*int`).
 ### 2. Разбор аргументов командной строки  
```go
flag.Parse()
```
Функция `flag.Parse()` анализирует переданные аргументы и присваивает значения переменным `city` и `fotmat`.  
Например, если запустить программу так:  
```sh
go run main.go -city Moscow -fotmat 2
```
то `*city` будет `"Moscow"`, а `*fotmat` — `2`.

### 3. Вывод города  
```go
fmt.Println(*city)
```
- `*city` разыменовывает указатель и выводит название города в консоль.  
- Если флаг `-city` не был передан, выводится пустая строка `""`.

### 4. Получение геоданных  
```go
geoData, err := geo.GetMyLocation(*city)
if err != nil {
    fmt.Println(err.Error())
}
```
- Функция `geo.GetMyLocation(*city)` получает данные о местоположении по названию города.  
- Если происходит ошибка (`err != nil`), она выводится в консоль.

### 5. Вывод геоданных  
```go
fmt.Println(geoData)
```
- В консоли отображаются полученные данные о местоположении (`geoData`).

### 7. Получение погоды  
```go
weatherData, _ := weather.GetWeather(*geoData, *fotmat)
```
- Вызывается функция `weather.GetWeather`, которая получает погоду по геоданным и формату.  
- Ошибка игнорируется (`_` вместо обработки).

### 8. Вывод погоды  
```go
fmt.Println(weatherData)
```
- Выводит информацию о погоде в консоль.

## Ошибки и их обработка

- `NOCITY` – Город не найден или указан неверно.
- `NOT200` – Ошибка ответа от API определения местоположения.
- `ERROR_WRONG_FORMAT` – Указан некорректный формат прогноза.
- `ERROR_URL` – Ошибка формирования URL для запроса к API.
- `ERROR_HTTP` – Ошибка сетевого запроса.
- `ERROR_ReadBody` – Ошибка чтения ответа API.

## Зависимости

- `net/http` – для выполнения HTTP-запросов.
- `encoding/json` – для обработки JSON-ответов.
- `flag` – для обработки аргументов командной строки.

# weather
 Пакет `weather` предоставляет функцию для получения прогноза погоды с сервиса [wttr.in](https://wttr.in).  
Использует географические данные и позволяет запрашивать прогноз в разных форматах.

# geo

Пакет `geo` предоставляет функции для определения местоположения пользователя по IP и проверки существования города через API.  